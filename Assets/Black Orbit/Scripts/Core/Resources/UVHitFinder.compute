// -----------------------------------------------------------------------------
// Compute‑шейдер: ищет пересечение луча с треугольником и возвращает UV‑координаты
// ─  Для каждого треугольника (по одному на поток) вычисляем пересечение,
//    находим ближайший hit и атомарно обновляем общий результат.
// -----------------------------------------------------------------------------

#pragma kernel FindUV                   // ядро, вызываемое из C#

// ──────────────────────────
// Входные данные (ByteAddressBuffer — «сырые» байты, читаем .Load(...))
ByteAddressBuffer _VBuffer; // Вершинный буфер: все вершины «вперемешку»
ByteAddressBuffer _Indices; // Индексный буфер: 3 индекса на треугольник

// ──────────────────────────
// Параметры раскладки вершин (задаёт C#‑скрипт)
int _Stride; // Размер одной вершины в байтах
int _PosOffset; // Смещение позиции внутри вершины (byte)
int _PosHalf; // 1 → позиция хранится как float16 (half), 0 → float32
int _UVOffset; // Смещение текстурных координат внутри вершины (byte)
int _TriangleCount; // Всего треугольников
float _MaxDistance; // Максимальное расстояние до треугольника
int _UVIsHalf; // 1 → UV хранятся как float16 (half), 0 → float32
int _Is16BitIndex; // 1 → 16‑битные индексы, 0 → 32‑битные

// ──────────────────────────
// Параметры луча (могут задаваться мышкой / камерой и т.п.)
float3 _RayOrigin;
float3 _RayDirection;

// ──────────────────────────
// Выходные буферы (размер 1 элемент):
//   _BestDist[0] — расстояние до ближайшего пересечения (в виде uint битов)
//   _BestUV [0]  — UV‑координаты этого пересечения
RWStructuredBuffer<uint> _BestDist; // asuint(min distance)
RWStructuredBuffer<float2> _BestUV;

//=============================================================================
//                           ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
//=============================================================================

/* Загружаем индекс вершины (i0/i1/i2)
 *  - tri   : номер треугольника
 *  - vert  : 0, 1 или 2 (индекс внутри треугольника)                       */
uint LoadIndex(uint tri, uint vert)
{
    uint idx = tri * 3 + vert; // порядковый индекс (0..N)
    if (_Is16BitIndex != 0)
    {
        uint byteOffset = idx * 2; // 2 байта на индекс
        uint dword = _Indices.Load(byteOffset & ~3u); // выровняли адрес на 4
        // если адрес чётный (0,4,8) → берём младшие 16 бит,
        // если нечётный (2,6,10)  → старшие
        return ((byteOffset & 2u) == 0u) ? (dword & 0xFFFFu) : (dword >> 16);
    }

    return _Indices.Load(idx * 4); // 32‑битные индексы — всё просто
}

/* Читаем позицию float3 из _VBuffer */
float3 LoadPos(uint idx)
{
    uint base = idx * _Stride + _PosOffset;

    if (_PosHalf == 1)          // -------- Float16 (x,y) | Float16 (z,_)
    {
        uint lo = _VBuffer.Load(base);     // [y15..0 | x15..0]
        uint hi = _VBuffer.Load(base + 4); // [____ | z15..0]

        float x = f16tof32(lo & 0xFFFFu);
        float y = f16tof32(lo >> 16);
        float z = f16tof32(hi & 0xFFFFu);
        return float3(x, y, z);
    }

    // -------- Float32 (обычный путь)
    return float3(
        asfloat(_VBuffer.Load(base + 0)),
        asfloat(_VBuffer.Load(base + 4)),
        asfloat(_VBuffer.Load(base + 8)));
}

/* Читаем UV из _VBuffer: поддержка float32 и упакованного float16 */
float2 LoadUV(uint idx)
{
    uint base = idx * _Stride + _UVOffset;

    // ─ Float16 (две половинки в одном uint)
    if (_UVIsHalf == 1)
    {
        uint packed = _VBuffer.Load(base); // 32 бита = Uhalf | Vhalf
        uint2 h = uint2(packed & 0xFFFFu, packed >> 16);
        return float2(f16tof32(h.x), f16tof32(h.y));
    }

    // ─ Float32 (по 4 байта на компоненту)
    return float2(
        asfloat(_VBuffer.Load(base + 0)),
        asfloat(_VBuffer.Load(base + 4)));
}

/* Классический Möller–Trumbore: пересечение луч‑треугольник
 *   – возвращает true, если hit есть
 *   – t     — расстояние вдоль луча
 *   – bary  — барицентрические координаты (b0, b1, b2)                   */
bool RayTri(float3 ro, float3 rd,
            float3 v0, float3 v1, float3 v2,
            out float t, out float3 bary)
{
    float3 e1 = v1 - v0, e2 = v2 - v0; // ребра треугольника
    float3 p = cross(rd, e2);
    float det = dot(e1, p);

    // Луч параллелен плоскости — выходим
    if (abs(det) < 1e-6)
    {
        t = 0;
        bary = float3(0, 0, 0);
        return false;
    }

    float invDet = rcp(det);
    float3 s = ro - v0;
    float u = dot(s, p) * invDet; // барицентрическая u
    if (u < 0 || u > 1) return false;

    float3 q = cross(s, e1);
    float v = dot(rd, q) * invDet; // барицентрическая v
    if (v < 0 || u + v > 1) return false;
    
    t = dot(e2, q) * invDet; // расстояние до пересечения
    
    if (t == 0 || t > _MaxDistance) return false;
    
    bary = float3(1 - u - v, u, v); // (b0,b1,b2) = (w,u,v)
    return true;
}

//=============================================================================
//                                ГЛАВНОЕ ЯДРО
//=============================================================================
[numthreads(64,1,1)] // 64 треугольника обрабатываем параллельно
void FindUV(uint3 id : SV_DispatchThreadID)
{
    uint tri = id.x; // номер обрабатываемого треугольника
    if (tri >= (uint)_TriangleCount) return;

    // ──────────────────────────────────────────────────────────────────────
    // 1) Читаем три индекса и сами вершины
    uint i0 = LoadIndex(tri, 0);
    uint i1 = LoadIndex(tri, 1);
    uint i2 = LoadIndex(tri, 2);

    float3 v0 = LoadPos(i0);
    float3 v1 = LoadPos(i1);
    float3 v2 = LoadPos(i2);

    // ──────────────────────────────────────────────────────────────────────
    // 2) Тест пересечения луча с треугольником
    float t;
    float3 bary;
    if (!RayTri(_RayOrigin, _RayDirection, v0, v1, v2, t, bary))
    {
        return; // промах — заканчиваем поток
    }
    // ──────────────────────────────────────────────────────────────────────
    // 3) Атомарно обновляем минимальную дистанцию (InterlockedMin)
    uint distBits = asuint(t); // приводим float → uint для атомика
    uint prevBits; // сюда запишется предыдущее значение
    InterlockedMin(_BestDist[0], distBits, prevBits);

    // Если НОВОЕ расстояние оказалось меньше старого  это самый близкий hit
    if (distBits < prevBits)
    {
        // 4) Интерполяция UV по барицентрическим координатам
        float2 uv =
            bary.x * LoadUV(i0) +
            bary.y * LoadUV(i1) +
            bary.z * LoadUV(i2);

        _BestUV[0] = uv; // записываем лучший UV
    }
}
